`Request`和`Response`是在抽象类`AbstractProcessor`的构造函数中创建的
```java
    public AbstractProcessor() {
        this(new Request(), new Response());
    }

    protected AbstractProcessor(Request coyoteRequest, Response coyoteResponse) {
        asyncStateMachine = new AsyncStateMachine(this);
        request = coyoteRequest;
        response = coyoteResponse;
        response.setHook(this);
        request.setResponse(response);
        request.setHook(this);
    }
```
启动Tomcat后，在`AbstractProcessorLight#process()`方法中加断点，然后在浏览器中输入地址：http://127.0.0.1:8080/. 
1. 第一次的时候，会调用`AbstractProcessor`的构造函数（创建子类`Http11Processor`，第二次就不需要了，因为`AbstractProtocol#process()`中会将`processor`缓存起来）
2. 在`AbstractProcessorLight#process()`方法中，`status == SocketEvent.OPEN_READ`为真，所以调用`service()`方法，即`Http11Processor#service()`方法。
3. `Http11Processor#service()`方法中，根据处理进度不断调用`RequestInfo.setStage()`方法，将值设置为`Constants`的值：
```java
    // Request states
    public static final int STAGE_NEW = 0;
    public static final int STAGE_PARSE = 1;
    public static final int STAGE_PREPARE = 2;
    public static final int STAGE_SERVICE = 3;
    public static final int STAGE_ENDINPUT = 4;
    public static final int STAGE_ENDOUTPUT = 5;
    public static final int STAGE_KEEPALIVE = 6;
    public static final int STAGE_ENDED = 7;
```
4. `org.apache.coyote.Constants.STAGE_PARSE`. 调用`Http11InputBuffer#parseRequestLine()、parseHeaders()`方法解析Http头部。解析完头部后，信息保存在`Http11InputBuffer#MimeHeaders headers`中。然后单独对"upgrade"做了处理，从`headers`的`Connection`value中查找是否含有"upgrade"，如果有，则依次调用`AbstractProcessor#action()`方法：`action(ActionCode.CLOSE,  null);`、`action(ActionCode.UPGRADE, upgradeToken);`
5. `org.apache.coyote.Constants.STAGE_PREPARE`. 调用的是`Http11Processor#prepareRequest()`方法. `prepareRequest()`方法中，主要是调用了`Http11Processor#addInputFilter()`、`Http11InputBuffer#addActiveFilter()`方法，将`InputFilter`加入到`Http11InputBuffer#InputFilter[] activeFilters`中。`Http11Processor`构造函数中，已经为`inputBuffer(Http11InputBuffer)`和`outputBuffer(Http11OutputBuffer)`加入了filter：
```java
        inputBuffer = new Http11InputBuffer(request, protocol.getMaxHttpHeaderSize());
        request.setInputBuffer(inputBuffer);

        outputBuffer = new Http11OutputBuffer(response, protocol.getMaxHttpHeaderSize());
        response.setOutputBuffer(outputBuffer);

        // Create and add the identity filters.
        inputBuffer.addFilter(new IdentityInputFilter(protocol.getMaxSwallowSize()));
        outputBuffer.addFilter(new IdentityOutputFilter());

        // Create and add the chunked filters.
        inputBuffer.addFilter(new ChunkedInputFilter(protocol.getMaxTrailerSize(),
                protocol.getAllowedTrailerHeadersInternal(), protocol.getMaxExtensionSize(),
                protocol.getMaxSwallowSize()));
        outputBuffer.addFilter(new ChunkedOutputFilter());

        // Create and add the void filters.
        inputBuffer.addFilter(new VoidInputFilter());
        outputBuffer.addFilter(new VoidOutputFilter());

        // Create and add buffered input filter
        inputBuffer.addFilter(new BufferedInputFilter());

        // Create and add the chunked filters.
        //inputBuffer.addFilter(new GzipInputFilter());
        outputBuffer.addFilter(new GzipOutputFilter());
```
