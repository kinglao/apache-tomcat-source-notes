## `Servlet`的生命周期

### `StandardWrapper.singleThreadModel`
用来标识`Servlet`是否实现了`SingleThreadModel`接口. 设置`SingleThreadModel`的值的调用栈是：
```
    "main@1" prio=5 tid=0x1 nid=NA runnable
     java.lang.Thread.State: RUNNABLE
	  at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1083)
	  - locked <0xa28> (a org.apache.catalina.core.StandardWrapper)
	  at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:980)
	  at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4819)
	  at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5129)
	  - locked <0xa2a> (a org.apache.catalina.core.StandardContext)
	  at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	  at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:740)
	  at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:716)
	  at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:703)
	  at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1134)
	  at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1868)
	  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	  at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	  at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)
	  at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
	  at org.apache.catalina.startup.HostConfig.deployDirectories(HostConfig.java:1045)
	  at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:433)
	  at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1578)
	  at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:308)
	  at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:123)
	  at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:424)
	  - locked <0xa2b> (a org.apache.catalina.core.StandardHost)
	  at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:367)
	  at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:964)
	  at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:839)
	  at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	  at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1425)
	  at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1415)
	  at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	  at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)
	  at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
	  at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:941)
	  - locked <0xa5d> (a org.apache.catalina.core.StandardEngine)
	  at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:258)
	  at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	  at org.apache.catalina.core.StandardService.startInternal(StandardService.java:422)
	  at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	  - locked <0xa5e> (a org.apache.catalina.core.StandardService)
	  at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:770)
	  - locked <0xb02> (a java.lang.Object)
	  at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	  - locked <0xa5f> (a org.apache.catalina.core.StandardServer)
	  at org.apache.catalina.startup.Catalina.start(Catalina.java:657)
	  at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)
	  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	  at java.lang.reflect.Method.invoke(Method.java:498)
	  at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:355)
	  at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:495)
```
1. 可以看到，是在start过程中，通过`HostConfig.deployApps()`部署应用的过程中，`StandardHost`将`StandardContext`作为child加入到`StandardHost#children`中，然后调用`StandardContext`的`start()`方法。然后在`StandardContext#startInternal()`方法（5129行。在4993行调用了`fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null);`从而最终引起调用`addChild(Container child)`，将`StandardWrapper`加入到了`StandardContext`的children域中。所以在调用`StandardContext#loadOnStartup(findChildren())`方法的时候，`StandardContext`的children域中已经有了`StandardWrapper`值）中调用`StandardContext#loadOnStartup(findChildren())`方法。
 
2. `StandardContext#findChildren()`会返回所有的`StandardWrapper`。`StandardContext#loadOnStartup()`方法中，会找到所有的"load on startup" servlets。即<load-on-startup>设置大于等于0的Servlet。但是`JspServlet`除外，`JspServlet`必须被preloaded
```java
    public int getLoadOnStartup() {

        if (isJspServlet && loadOnStartup < 0) {
            /*
             * JspServlet must always be preloaded, because its instance is
             * used during registerJMX (when registering the JSP
             * monitoring mbean)
             */
             return Integer.MAX_VALUE;
        } else {
            return this.loadOnStartup;
        }
    }
```
3. 然后以`loadOnStartup`为key，将`StandardWrapper`放入到`TreeMap<Integer, ArrayList<Wrapper>> map`中：
```java
        public boolean loadOnStartup(Container children[]) {

        // Collect "load on startup" servlets that need to be initialized
        TreeMap<Integer, ArrayList<Wrapper>> map = new TreeMap<>();
        for (int i = 0; i < children.length; i++) {
            Wrapper wrapper = (Wrapper) children[i];
            int loadOnStartup = wrapper.getLoadOnStartup();
            if (loadOnStartup < 0)
                continue;
            Integer key = Integer.valueOf(loadOnStartup);
            ArrayList<Wrapper> list = map.get(key);
            if (list == null) {
                list = new ArrayList<>();
                map.put(key, list);
            }
            list.add(wrapper);
        }

        // Load the collected "load on startup" servlets
        for (ArrayList<Wrapper> list : map.values()) {
            for (Wrapper wrapper : list) {
                try {
                    wrapper.load();
                } catch (ServletException e) {
                    getLogger().error(sm.getString("standardContext.loadOnStartup.loadException",
                          getName(), wrapper.getName()), StandardWrapper.getRootCause(e));
                    // NOTE: load errors (including a servlet that throws
                    // UnavailableException from the init() method) are NOT
                    // fatal to application startup
                    // unless failCtxIfServletStartFails="true" is specified
                    if(getComputedFailCtxIfServletStartFails()) {
                        return false;
                    }
                }
            }
        }
        return true;

    }
```
对于没有配置"load on startup" servlets，不会在start阶段调用`StandardWrapper`的`load()`方法。同时可以看到<load-on-startup>值越小，越先调用该`StandardWrapper`的`load()`方法。
4. `StandardWrapper`的`load()`方法中会调用`StandardWrapper#loadServlet()`方法，并将返回的`Servlet`保存在`StandardWrapper#instance`域中。

### `init()`
在上面的`StandardWrapper`的`load()`方法中，会调用`StandardWrapper`的`loadServlet()`方法，先设置`StandardWrapper#singleThreadModel`的值，然后调用`StandardWrapper#initServlet()`方法，在该方法中，调用`Servlet#init()`方法。初始化完成之后，会设置`StandardWrapper#instanceInitialized`域为true，从而保证`Servlet#init()`方法只调用一次。

### `service()`

### `destroy()`
