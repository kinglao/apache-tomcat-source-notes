`Nio2Endpoint`对应的是`Nio2`，相对于`Nio1`，`Nio2`使用的是以`Asynchronous`开头的channel，即异步的channel，其特点是方法的返回值放回的是`Future`，例如`accept()`方法、`read()`方法、`write()`方法。</br>
NIO2:
```java
    // AsynchronousServerSocketChannel.java
    public abstract Future<AsynchronousSocketChannel> accept();

    // AsynchronousSocketChannel.java
    public abstract Future<Integer> read(ByteBuffer dst);
    // AsynchronousSocketChannel.java
    public abstract Future<Integer> write(ByteBuffer src);

```

NIO1:
```java
    // ServerSocketChannel.java
    public abstract SocketChannel accept() throws IOException;
    
    // SocketChannel.java
    public abstract int read(ByteBuffer dst) throws IOException;
    // SocketChannel.java
    public abstract int write(ByteBuffer src) throws IOException;

```
## init()
同NioEndpoint. </br>
最后会调用到`Nio2Endpoint#bind()`方法:</br>
1. 创建线程池和`AsynchronousChannelGroup`对象
```java
        // Create worker collection
        if ( getExecutor() == null ) {
            createExecutor();
        }
        if (getExecutor() instanceof ExecutorService) {
            threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService) getExecutor());
        }
```
2. 创建并设置` AsynchronousServerSocketChannel`属性，并且绑定bind(). 将acceptorThreadCount设置为1
```java
serverSock = AsynchronousServerSocketChannel.open(threadGroup);
socketProperties.setProperties(serverSock);
InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));
serverSock.bind(addr,getAcceptCount());

// Initialize thread count defaults for acceptor, poller
if (acceptorThreadCount != 1) {
    // NIO2 does not allow any form of IO concurrency
    acceptorThreadCount = 1;
}
```
3. initialiseSsl()

## start()
同NioEndpoint. </br>
### Nio2Endpoint#startInternal()
```java
    public void startInternal() throws Exception {

        if (!running) {
            allClosed = false;
            running = true;
            paused = false;

            processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
                    socketProperties.getProcessorCache());
            nioChannels = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
                    socketProperties.getBufferPool());

            // Create worker collection
            if ( getExecutor() == null ) {
                createExecutor();
            }

            initializeConnectionLatch();
            startAcceptorThreads();
        }
    }

```
可以看到和`NioEndpoint`是类似的，不同的是`Nio2Endpoint`里面是不用`Poller`的，因为并不需要做轮询。
## 闭锁（Latch）
`Nio2Endpoint`只有一个闭锁，在`startInternal()`方法中调用了`AbstractEndpoint#initializeConnectionLatch()`方法，为`AbstractEndpoint`的`connectionLimitLatch`域设置值:`LimitLatch connectionLimitLatch = new LimitLatch(this.maxConnections)`。初始数量的默认值是10000：`private int maxConnections = 10000;`
