以`Http11InputBuffer`和`Http11OutputBuffer`为例介绍`InputBuffer`和`OutputBuffer`。</br>

Tomcat用到了四个`ByteBuffer`
1. `SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`、`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`. 创建是在`SocketBufferHandler`构造函数中。而`SocketBufferHandler`的创建是在`AbstractEndpoint#setSocketOptions()`抽象方法的实现中。
```java
    public SocketBufferHandler(int readBufferSize, int writeBufferSize,
            boolean direct) {
        this.direct = direct;
        if (direct) {
            readBuffer = ByteBuffer.allocateDirect(readBufferSize);
            writeBuffer = ByteBuffer.allocateDirect(writeBufferSize);
        } else {
            readBuffer = ByteBuffer.allocate(readBufferSize);
            writeBuffer = ByteBuffer.allocate(writeBufferSize);
        }
    }
```
`readBufferSize`、`writeBufferSize`的大小是在`SocketProperties#int appReadBufSize = 8192`、`SocketProperties#int appWriteBufSize = 8192`，单位是字节。
2. `Http11InputBuffer#ByteBuffer byteBuffer` 。创建是在`Http11InputBuffer#init()`方法中
```java
       void init(SocketWrapperBase<?> socketWrapper) {

        wrapper = socketWrapper;
        wrapper.setAppReadBufHandler(this);

        int bufLength = headerBufferSize +
                wrapper.getSocketBufferHandler().getReadBuffer().capacity();
        if (byteBuffer == null || byteBuffer.capacity() < bufLength) {
            byteBuffer = ByteBuffer.allocate(bufLength);
            byteBuffer.position(0).limit(0);
        }
    } 
```
buffer的大小是：`headerBufferSize + wrapper.getSocketBufferHandler().getReadBuffer().capacity();`，即`AbstractHttp11Protocol#int maxHttpHeaderSize = 8 * 1024`加上`SocketProperties#int appReadBufSize = 8192`，总共16k。
3. `Http11OutputBuffer#ByteBuffer headerBuffer`。创建是在`Http11OutputBuffer`构造方法中。
```java
    protected Http11OutputBuffer(Response response, int headerBufferSize) {

        this.response = response;

        headerBuffer = ByteBuffer.allocate(headerBufferSize);

        filterLibrary = new OutputFilter[0];
        activeFilters = new OutputFilter[0];
        lastActiveFilter = -1;

        responseFinished = false;

        outputStreamOutputBuffer = new SocketOutputBuffer();
    }
```
`Http11OutputBuffer`是在`Http11Processor`构造方法中创建的。
```java
        outputBuffer = new Http11OutputBuffer(response, protocol.getMaxHttpHeaderSize());
```
buffer大小是`protocol.getMaxHttpHeaderSize()`，即`AbstractHttp11Protocol#int maxHttpHeaderSize = 8 * 1024`.

## `Http11InputBuffer`
从socket中读数据。以Nio为例，调用栈：
```
"http-nio-8080-exec-7@2752" daemon prio=5 tid=0x1f nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1083)
	  at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:707)
	  at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:346)
	  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:380)
	  at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	  at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:796)
	  at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1372)
	  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	  - locked <0xc7e> (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	  at java.lang.Thread.run(Thread.java:745)
```
`NioEndpoint$NioSocketWrapper.read()`方法：
```java
        public int read(boolean block, ByteBuffer to) throws IOException {
            int nRead = populateReadBuffer(to);
            if (nRead > 0) {
                return nRead;
                /*
                 * Since more bytes may have arrived since the buffer was last
                 * filled, it is an option at this point to perform a
                 * non-blocking read. However correctly handling the case if
                 * that read returns end of stream adds complexity. Therefore,
                 * at the moment, the preference is for simplicity.
                 */
            }

            // The socket read buffer capacity is socket.appReadBufSize
            int limit = socketBufferHandler.getReadBuffer().capacity();
            if (to.remaining() >= limit) {
                to.limit(to.position() + limit);
                nRead = fillReadBuffer(block, to);
                updateLastRead();
            } else {
                // Fill the read buffer as best we can.
                nRead = fillReadBuffer(block);
                updateLastRead();

                // Fill as much of the remaining byte array as possible with the
                // data that was just read
                if (nRead > 0) {
                    nRead = populateReadBuffer(to);
                }
            }
            return nRead;
        }
```
`SocketWrapperBase#populateReadBuffer()`方法
```java
    protected int populateReadBuffer(ByteBuffer to) {
        // Is there enough data in the read buffer to satisfy this request?
        // Copy what data there is in the read buffer to the byte array
        socketBufferHandler.configureReadBufferForRead();
        int nRead = transfer(socketBufferHandler.getReadBuffer(), to);

        if (log.isDebugEnabled()) {
            log.debug("Socket: [" + this + "], Read from buffer: [" + nRead + "]");
        }
        return nRead;
    }
    
    protected static int transfer(ByteBuffer from, ByteBuffer to) {
        int max = Math.min(from.remaining(), to.remaining());
        if (max > 0) {
            int fromLimit = from.limit();
            from.limit(from.position() + max);
            to.put(from);
            from.limit(fromLimit);
        }
        return max;
    }
```
`transfer()`方法：
1. 如果from或者to中有一个满了，则不转移数据，返回0
2. 如果from的remaining FR大于to的remaining TR，则max是TR，则从from中将TR容量的数据转移到to中，from中还有 FR-TR 的数据没转移。
3. 如果from的remaining FR小于to的remaining TR，则max是FR，则从from中将FR容量的数据转移到to中，from中已经没有数据了
`NioEndpoint$NioSocketWrapper.read()`方法：
1. `SocketWrapperBase.populateReadBuffer()`的作用是将`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中的数据转移到`Http11InputBuffer#ByteBuffer byteBuffer`中。实际调用的是上面的`transfer()`方法，如果`transfer()`方法不返回0，则`read()`方法结束。走到下面的步骤说明其中一个buffer满了。
2. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`，调用`nRead = fillReadBuffer(block, to);`将数据从socket中读到`Http11InputBuffer#ByteBuffer byteBuffer`。结束
3. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`，调用`nRead = fillReadBuffer(block);`，将数据从socket中读到`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中（填满？），然后再从`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中转移到`Http11InputBuffer#ByteBuffer byteBuffer`中。结束。

## `Http11OutputBuffer`
向socket中写数据。
```
"http-nio-8080-exec-7@2752" daemon prio=5 tid=0x1f nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:400)
	  at org.apache.coyote.http11.Http11OutputBuffer.commit(Http11OutputBuffer.java:327)
	  at org.apache.coyote.http11.Http11Processor.prepareResponse(Http11Processor.java:1007)
	  at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:262)
	  at org.apache.coyote.Response.action(Response.java:176)
	  at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:193)
	  at org.apache.coyote.Response.doWrite(Response.java:538)
	  at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:328)
	  at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:748)
	  at org.apache.catalina.connector.OutputBuffer.realWriteChars(OutputBuffer.java:433)
	  at org.apache.catalina.connector.OutputBuffer.flushCharBuffer(OutputBuffer.java:753)
	  at org.apache.catalina.connector.OutputBuffer.close(OutputBuffer.java:222)
	  at org.apache.catalina.connector.Response.finishResponse(Response.java:480)
	  at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:373)
	  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:498)
	  at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	  at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:796)
	  at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1372)
	  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	  - locked <0xc7e> (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	  at java.lang.Thread.run(Thread.java:745)

```

```java
    public final void write(boolean block, ByteBuffer from) throws IOException {
        if (from == null || from.remaining() == 0) {
            return;
        }

        // While the implementations for blocking and non-blocking writes are
        // very similar they have been split into separate methods to allow
        // sub-classes to override them individually. NIO2, for example,
        // overrides the non-blocking write but not the blocking write.
        if (block) {
            writeBlocking(from);
        } else {
            writeNonBlocking(from);
        }
    }
    
        protected void writeBlocking(ByteBuffer from) throws IOException {
        // Note: There is an implementation assumption that if the switch from
        // non-blocking to blocking has been made then any pending
        // non-blocking writes were flushed at the time the switch
        // occurred.

        // If it is possible write the data to the socket directly from the
        // provided buffer otherwise transfer it to the socket write buffer
        if (socketBufferHandler.isWriteBufferEmpty()) {
            writeByteBufferBlocking(from);
        } else {
            socketBufferHandler.configureWriteBufferForWrite();
            transfer(from, socketBufferHandler.getWriteBuffer());
            if (!socketBufferHandler.isWriteBufferWritable()) {
                doWrite(true);
                writeByteBufferBlocking(from);
            }
        }
    }
```
1. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中没有数据，将`Http11OutputBuffer#ByteBuffer headerBuffer`中的数据直接写入到socket，并且如果`Http11OutputBuffer#ByteBuffer headerBuffer`中数据没有全部写入socket中，则将剩余数据transfer到`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中。结束。
2. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中有数据，先将`Http11OutputBuffer#ByteBuffer headerBuffer`中的一部分数据写入到`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中（填满？），然后将`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中数据写入到socket中，然后将`Http11OutputBuffer#ByteBuffer headerBuffer`中剩余数据写入到socket中。
