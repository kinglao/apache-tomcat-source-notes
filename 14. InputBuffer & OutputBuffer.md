以`Http11InputBuffer`和`Http11OutputBuffer`为例介绍`InputBuffer`和`OutputBuffer`。
用到了四个`ByteBuffer`：`Http11InputBuffer#ByteBuffer byteBuffer`、`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`、`Http11OutputBuffer#ByteBuffer headerBuffer`、`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`

## `Http11InputBuffer`
以Nio为例，调用栈：
```
"http-nio-8080-exec-7@2752" daemon prio=5 tid=0x1f nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1083)
	  at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:707)
	  at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:346)
	  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:380)
	  at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	  at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:796)
	  at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1372)
	  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	  - locked <0xc7e> (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	  at java.lang.Thread.run(Thread.java:745)
```
`NioEndpoint$NioSocketWrapper.read()`方法：
```java
        public int read(boolean block, ByteBuffer to) throws IOException {
            int nRead = populateReadBuffer(to);
            if (nRead > 0) {
                return nRead;
                /*
                 * Since more bytes may have arrived since the buffer was last
                 * filled, it is an option at this point to perform a
                 * non-blocking read. However correctly handling the case if
                 * that read returns end of stream adds complexity. Therefore,
                 * at the moment, the preference is for simplicity.
                 */
            }

            // The socket read buffer capacity is socket.appReadBufSize
            int limit = socketBufferHandler.getReadBuffer().capacity();
            if (to.remaining() >= limit) {
                to.limit(to.position() + limit);
                nRead = fillReadBuffer(block, to);
                updateLastRead();
            } else {
                // Fill the read buffer as best we can.
                nRead = fillReadBuffer(block);
                updateLastRead();

                // Fill as much of the remaining byte array as possible with the
                // data that was just read
                if (nRead > 0) {
                    nRead = populateReadBuffer(to);
                }
            }
            return nRead;
        }
```
1. `SocketWrapperBase.populateReadBuffer()`的作用是将`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中的数据转移到`Http11InputBuffer#ByteBuffer byteBuffer`中。如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中有数据，成功转移到`Http11InputBuffer#ByteBuffer byteBuffer`中，则返回。否则，执行下面的操作。
2. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`，调用`nRead = fillReadBuffer(block, to);`将数据从socket中读到`Http11InputBuffer#ByteBuffer byteBuffer`。结束
3. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`，调用`nRead = fillReadBuffer(block);`，将数据从socket中读到`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中（填满？），然后再从`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer readBuffer`中转移到`Http11InputBuffer#ByteBuffer byteBuffer`中。结束。

## `Http11OutputBuffer`

```
"http-nio-8080-exec-7@2752" daemon prio=5 tid=0x1f nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:400)
	  at org.apache.coyote.http11.Http11OutputBuffer.commit(Http11OutputBuffer.java:327)
	  at org.apache.coyote.http11.Http11Processor.prepareResponse(Http11Processor.java:1007)
	  at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:262)
	  at org.apache.coyote.Response.action(Response.java:176)
	  at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:193)
	  at org.apache.coyote.Response.doWrite(Response.java:538)
	  at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:328)
	  at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:748)
	  at org.apache.catalina.connector.OutputBuffer.realWriteChars(OutputBuffer.java:433)
	  at org.apache.catalina.connector.OutputBuffer.flushCharBuffer(OutputBuffer.java:753)
	  at org.apache.catalina.connector.OutputBuffer.close(OutputBuffer.java:222)
	  at org.apache.catalina.connector.Response.finishResponse(Response.java:480)
	  at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:373)
	  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:498)
	  at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	  at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:796)
	  at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1372)
	  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	  - locked <0xc7e> (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	  at java.lang.Thread.run(Thread.java:745)

```

```java
    public final void write(boolean block, ByteBuffer from) throws IOException {
        if (from == null || from.remaining() == 0) {
            return;
        }

        // While the implementations for blocking and non-blocking writes are
        // very similar they have been split into separate methods to allow
        // sub-classes to override them individually. NIO2, for example,
        // overrides the non-blocking write but not the blocking write.
        if (block) {
            writeBlocking(from);
        } else {
            writeNonBlocking(from);
        }
    }
    
        protected void writeBlocking(ByteBuffer from) throws IOException {
        // Note: There is an implementation assumption that if the switch from
        // non-blocking to blocking has been made then any pending
        // non-blocking writes were flushed at the time the switch
        // occurred.

        // If it is possible write the data to the socket directly from the
        // provided buffer otherwise transfer it to the socket write buffer
        if (socketBufferHandler.isWriteBufferEmpty()) {
            writeByteBufferBlocking(from);
        } else {
            socketBufferHandler.configureWriteBufferForWrite();
            transfer(from, socketBufferHandler.getWriteBuffer());
            if (!socketBufferHandler.isWriteBufferWritable()) {
                doWrite(true);
                writeByteBufferBlocking(from);
            }
        }
    }
```
1. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中没有数据，将`Http11OutputBuffer#ByteBuffer headerBuffer`中的数据直接写入到socket，并且如果`Http11OutputBuffer#ByteBuffer headerBuffer`中数据没有全部写入socket中，则将剩余数据transfer到`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中。结束。
2. 如果`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中有数据，先将`Http11OutputBuffer#ByteBuffer headerBuffer`中的一部分数据写入到`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中（填满？），然后将`SocketWrapperBase#SocketBufferHandler socketBufferHandler#ByteBuffer writeBuffer`中数据写入到socket中，然后将`Http11OutputBuffer#ByteBuffer headerBuffer`中剩余数据写入到socket中。
